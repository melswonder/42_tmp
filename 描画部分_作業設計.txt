
<全体方針>
まずは１つでもいいのでなにかminilibxで描画する。
マップの読み込み結果が２Dで正しく描画出来ていることを確認する。
常に２Dでどのような状態か見れるようにしてデバッグしながら
３Dに描画を変換していく。

その他：描画のレイヤーを意識する。背景→3D→minimapの順で上に重ねるように描画


<参考>

< プログラム構成 >
1. Rendering（基本的な描画：背景、ミニマップ、初期位置）
2. Raycast （光線の衝突判定する。→衝突場所に描画＆衝突距離に応じて描画）
3. Move_player （プレーヤーを動かす）



＜作業ステップ＞

1. Rendering
Rederingとは:コンピュータグラフィックにおいては、データを処理もしくは演算することで画像や映像・テキストなどを表示させること
（描画すること）

<Rendering実施ステップ>
1-0: まずはmlxで１つの点、または線を描画する
1-1: 背景の描画（天井・床）
1-2: minimapの表示（parse=構文解析の描画結果確認）
1-3: プレーヤーの位置を描画
1-4: プレイヤーの向きを描画（視野角、見える範囲の角度まで描けるとよい）

<詳細>
1-0: まずはmlxで１つの点、または線を描画する
1-0-1: init_mlx, init_mlx_window をしてmlxを起動
1-0-2: t_img型（今回はt_cub_img型）の初期化および、mlx_addrで、bits_perpixel, line_sizeなどの数値入力
1-0-3: ft_mlx_put_pixelを準備（１点ずつでなく、メモリに書き込む）
1-0-4: mlx_put_image_to_windowなどで、winにimageから出力

1-1:背景の描画（天井・床）
1-1-1: 画面サイズの縦の上半分なら天井、した半分なら床にする。まずは固定色でOK
1-1-2: 固定色でなく、入力情報から色を描画（RGBを16進数変換する）

1-2: minimapの表示（parse=構文解析の描画結果確認）
1-2-1: 最初は壁は白、通路は青など簡単に色分け（黒・背景の天井・床とは色をわける）
Point:読み込んだマップが正しく描画できているか確認する
※ここが合わなければraycast してもあうことはない

1-4: プレイヤーの向きを描画（視野角、見える範囲の角度まで描画できるとよい）
Why? : Raycasting, Moving時の角度処理を行う時に状態確認しやすくする
1-4-1: 初期入力から視野角を定義して、方向線をminimapに描画する


2. Raycast
Raycastと:指定した場所から光線（Ray）を飛ばし、そのRayが衝突したオブジェクトを検知する

<Raycast実施ステップ>
2-1: レイが正しく伸びるかの基本チェック。
2-2: 壁の当たり判定の基本部分を作る
2-3: 疑似3D描画をする（画面の横面積分、全体にレイを放つ）
2-4: 奥行き感のある壁を描画する（壁の高さの決定）
2-5: 壁の面に応じて「色を変える」
2-6: 壁のゆがみを補正する（光線の斜めに放った距離では視覚との補正がされてない）
2-7: 向きに応じて壁にテキスチャ（模様）を入れる


<詳細>
2-1: レイが正しく伸びるかの基本チェック。
How ?: 1本だけレイを撃つ（debug）
2-1-1: プレイヤーから1方向にレイ（直線）を飛ばし、どの壁に当たったかチェック。
2-1-2: 壁にぶつかった座標を printf するか、ミニマップ上に「●」を描く。
※先にミニマップを作ったほうがやりやすいかもしれない

2-2: 当たり判定の基本部分を作る
How?: DDAアルゴリズムで「いつ壁に当たるか」を検出
2-2-1: DDA（Digital Differential Analyzer）を使ってグリッド上を少しずつ進み、壁に当たるまでループ。
2-2-2: 簡単なマップで「どのマスに当たったか」がわかればOK。

2-3: 疑似3D描画をする
How?: 画面横幅ぶん、全体にレイを撃つ
2-3-1: for （int x = 0; x < SCREEN_WIDTH; x++） で1ピクセルごとにレイを飛ばす。
2-3-2: プレイヤーの視野角とスクリーン上の位置（cameraX）に応じてレイの角度をずらす。

2-4: 奥行き感のある壁が見えるようにする。
How?: 壁までの距離から「縦の線（壁）」を描画
2-4-1: 壁（点）までの距離を測り、距離に反比例して壁の高さを決める 
2-4-2: 縦線を記載する

2-5: 壁の面に応じて「色を変える」
2-5-1: N/S/E/Wの壁で色を分ける （例：N→赤、S→青、E→緑、W→黄）. 
How? どの軸で衝突したかの判定をして判断。
Point: テクスチャを入れる前に方向感を取れているか確認する

2-6: 壁のゆがみを補正する （そもそも）
How?:  魚眼補正（Fisheye fix）を使う。レイの角度が変わると、距離が実際より短くなる歪みを補正

補正前の例：https://digital-faq.jp.omsystem.com/faq/public/app/servlet/qadoc?QID=007312

発生事象: 画面の端の壁が近く見えてしまう（＝歪む）
発生理由: レイを斜めに撃った距離をそのまま使っているため
対応方法：cos補正を入れて「視線との角度」を補正する
修正式: 補正後の距離  = 測定距離 *  cos（レイの角度 - プレーヤーの向いている角度）

2-7: 壁に向きに応じたテクスチャを適用する
2-7-1: 当たった面・座標を取得する
2-7-2: テクスチャのx座標を決定してそのときの色を取得して描画する

3:  Move_player
3-1: 初期の向き設定を行う
3-2: キーボードからの情報受取（キーイベント）の設定（１つでもOK）
3-3: プレーヤーの前後移動の実装
3-4: プレーヤーの左右移動の実装
3-5: プレーヤーの回転の実装
3-6: 衝突判定（←余裕があれば。minimap見ながらやる？）

※minimapで視野角を描画しておくことで、デバッグを楽にする
